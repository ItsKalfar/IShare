{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/Ishare.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\nerror NotOwner();\r\nerror NotSigned();\r\nerror NotRequestedYet();\r\nerror NotValidInput();\r\nerror SamePerson();\r\nerror AlreadySigned();\r\nerror AlreadyRequested();\r\nerror NotVerifier();\r\n\r\ncontract IShare {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter public _userID;\r\n\r\n    struct UserCredentials {\r\n        uint256 userNo;\r\n        address userId;\r\n        string userName;\r\n        string userLocation;\r\n        uint256 userAge;\r\n        bool userSigned;\r\n        bool isseuerSigned;\r\n        address issuerId;\r\n        uint256 issueDate;\r\n    }\r\n\r\n    mapping(uint256 => UserCredentials) public s_Users;\r\n    mapping(address => UserCredentials) public s_allUsers;\r\n    mapping(address => bool) public s_permittedVerfier;\r\n\r\n    event RequestSent();\r\n    event CredentialsIssued();\r\n    event CredentialsAcepted();\r\n    event GiveConcent();\r\n    event ConcentRevoked();\r\n\r\n    function requestCredentials(\r\n        string memory _name,\r\n        string memory _location,\r\n        uint256 _age\r\n    ) external {\r\n        if (s_allUsers[msg.sender].userId == msg.sender) {\r\n            revert AlreadyRequested();\r\n        }\r\n        if (_age <= 0) {\r\n            revert NotValidInput();\r\n        }\r\n        _userID.increment();\r\n        uint256 currentId = _userID.current();\r\n        s_allUsers[msg.sender] = UserCredentials(\r\n            currentId,\r\n            msg.sender,\r\n            _name,\r\n            _location,\r\n            _age,\r\n            false,\r\n            false,\r\n            address(0),\r\n            block.timestamp\r\n        );\r\n        s_Users[currentId] = UserCredentials(\r\n            currentId,\r\n            msg.sender,\r\n            _name,\r\n            _location,\r\n            _age,\r\n            false,\r\n            false,\r\n            address(0),\r\n            block.timestamp\r\n        );\r\n        emit RequestSent();\r\n    }\r\n\r\n    function issueCredentials(address userId, uint256 userNo) external {\r\n        if (s_allUsers[userId].userAge <= 0) {\r\n            revert NotRequestedYet();\r\n        }\r\n        if (s_allUsers[userId].userId == msg.sender) {\r\n            revert SamePerson();\r\n        }\r\n        if (s_allUsers[userId].isseuerSigned == true) {\r\n            revert AlreadySigned();\r\n        }\r\n        s_allUsers[userId].issuerId = msg.sender;\r\n        s_allUsers[userId].isseuerSigned = true;\r\n        s_Users[userNo].issuerId = msg.sender;\r\n        s_Users[userNo].isseuerSigned = true;\r\n        emit CredentialsIssued();\r\n    }\r\n\r\n    function acceptCredentials(address userId, uint256 userNo) external {\r\n        if (s_allUsers[userId].userAge <= 0) {\r\n            revert NotRequestedYet();\r\n        }\r\n        if (s_allUsers[userId].userId != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        if (s_allUsers[userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        s_allUsers[userId].userSigned = true;\r\n        s_allUsers[userId].issueDate = block.timestamp;\r\n        s_Users[userNo].userSigned = true;\r\n        s_Users[userNo].issueDate = block.timestamp;\r\n        emit CredentialsAcepted();\r\n    }\r\n\r\n    function giveConcent(address userId, address recipientId) external {\r\n        if (s_allUsers[userId].userId != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        if (s_allUsers[userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n\r\n        s_permittedVerfier[recipientId] = true;\r\n        emit GiveConcent();\r\n    }\r\n\r\n    function revokeConcent(address userId, address recipientId) external {\r\n        if (s_allUsers[userId].userId != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        if (s_allUsers[userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        s_permittedVerfier[recipientId] = false;\r\n        emit ConcentRevoked();\r\n    }\r\n\r\n    function checkConcent(\r\n        address userId,\r\n        address recipientId\r\n    ) public view returns (bool) {\r\n        if (s_allUsers[userId].userId != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        if (s_allUsers[userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        if (s_permittedVerfier[recipientId] == true) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function verifyUser(\r\n        address userId,\r\n        address recipientId\r\n    ) public view returns (bool) {\r\n        if (recipientId != msg.sender) {\r\n            revert NotVerifier();\r\n        }\r\n        if (s_allUsers[userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n\r\n        if (s_permittedVerfier[recipientId] == true) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}