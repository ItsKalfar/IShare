{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/Ishare.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\nerror NotOwner();\r\nerror NotSigned();\r\nerror NotRequestedYet();\r\nerror NotValidInput();\r\nerror SamePerson();\r\nerror AlreadySigned();\r\nerror NotVerifier();\r\n\r\ncontract IShare {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter public _userID;\r\n    Counters.Counter public _requestedID;\r\n\r\n    struct UserCredentials {\r\n        uint256 userId;\r\n        address userAddress;\r\n        string userName;\r\n        string userLocation;\r\n        uint256 userAge;\r\n        bool userSigned;\r\n        bool isseuerSigned;\r\n        address issuerId;\r\n        uint256 issueDate;\r\n    }\r\n\r\n    mapping(uint256 => UserCredentials) public s_allUsers;\r\n    mapping(uint256 => address) public s_requestedVerifier;\r\n    mapping(address => bool) public s_permittedVerfier;\r\n\r\n    event RequestSent();\r\n    event CredentialsIssued();\r\n    event CredentialsAcepted();\r\n    event GiveConcent();\r\n    event ConcentRevoked();\r\n\r\n    function requestCredentials(\r\n        string memory _name,\r\n        string memory _location,\r\n        uint256 _age\r\n    ) external {\r\n        if (_age <= 0) {\r\n            revert NotValidInput();\r\n        }\r\n        _userID.increment();\r\n        uint256 currentId = _userID.current();\r\n        s_allUsers[currentId] = UserCredentials(\r\n            currentId,\r\n            msg.sender,\r\n            _name,\r\n            _location,\r\n            _age,\r\n            false,\r\n            false,\r\n            address(0),\r\n            block.timestamp\r\n        );\r\n        emit RequestSent();\r\n    }\r\n\r\n    function issueCredentials(uint256 _userId) external {\r\n        if (s_allUsers[_userId].userAge <= 0) {\r\n            revert NotRequestedYet();\r\n        }\r\n        if (s_allUsers[_userId].userAddress == msg.sender) {\r\n            revert SamePerson();\r\n        }\r\n        if (s_allUsers[_userId].isseuerSigned == true) {\r\n            revert AlreadySigned();\r\n        }\r\n        s_allUsers[_userId].issuerId = msg.sender;\r\n        s_allUsers[_userId].isseuerSigned = true;\r\n        emit CredentialsIssued();\r\n    }\r\n\r\n    function dismissRequest(uint256 _userId) external {\r\n        if (s_allUsers[_userId].userAge <= 0) {\r\n            revert NotRequestedYet();\r\n        }\r\n        if (s_allUsers[_userId].userAddress == msg.sender) {\r\n            revert SamePerson();\r\n        }\r\n        if (s_allUsers[_userId].isseuerSigned == true) {\r\n            revert AlreadySigned();\r\n        }\r\n\r\n        delete s_allUsers[_userId];\r\n    }\r\n\r\n    function acceptCredentials(uint256 _userId) external {\r\n        if (s_allUsers[_userId].userAge <= 0) {\r\n            revert NotRequestedYet();\r\n        }\r\n        if (s_allUsers[_userId].userAddress != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        if (s_allUsers[_userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        s_allUsers[_userId].userSigned = true;\r\n        s_allUsers[_userId].issueDate = block.timestamp;\r\n        emit CredentialsAcepted();\r\n    }\r\n\r\n    function requestConcent() external {\r\n        _requestedID.increment();\r\n        uint256 currentId = _requestedID.current();\r\n        s_requestedVerifier[currentId] = msg.sender;\r\n    }\r\n\r\n    function giveConcent(\r\n        uint256 _userId,\r\n        uint256 _recipientId,\r\n        address recipientId\r\n    ) external {\r\n        if (s_allUsers[_userId].userAddress != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        if (s_allUsers[_userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        if (s_requestedVerifier[_recipientId] != recipientId) {\r\n            revert NotRequestedYet();\r\n        }\r\n\r\n        s_permittedVerfier[recipientId] = true;\r\n        emit GiveConcent();\r\n    }\r\n\r\n    function revokeConcent(uint256 _userId, address recipientId) external {\r\n        if (s_allUsers[_userId].userAddress != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        if (s_allUsers[_userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        s_permittedVerfier[recipientId] = false;\r\n        emit ConcentRevoked();\r\n    }\r\n\r\n    function checkConcent(uint256 _userId) public view returns (bool) {\r\n        if (s_allUsers[_userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        if (s_permittedVerfier[msg.sender] == true) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function verifyUser(uint256 _userId) public view returns (bool) {\r\n        if (s_allUsers[_userId].isseuerSigned == false) {\r\n            revert NotSigned();\r\n        }\r\n        if (s_allUsers[_userId].userAddress == msg.sender) {\r\n            revert SamePerson();\r\n        }\r\n\r\n        if (s_permittedVerfier[msg.sender] != true) {\r\n            revert NotVerifier();\r\n        }\r\n        for (uint i = 18; i <= 50; i++) {\r\n            if (\r\n                keccak256(abi.encode(s_allUsers[_userId].userAge)) ==\r\n                keccak256(abi.encode(i))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getCurrentUserId() external view returns (uint256) {\r\n        return _userID.current();\r\n    }\r\n\r\n    function getCurrentrecipientId() external view returns (uint256) {\r\n        return _requestedID.current();\r\n    }\r\n\r\n    function getUsers(\r\n        uint256 _userCurrentId\r\n    ) external view returns (UserCredentials memory) {\r\n        return s_allUsers[_userCurrentId];\r\n    }\r\n\r\n    function getPermittedVerifier(\r\n        address _verifierAddress\r\n    ) external view returns (bool) {\r\n        return s_permittedVerfier[_verifierAddress];\r\n    }\r\n\r\n    function requestedAccounts(\r\n        uint256 _userId\r\n    ) external view returns (address) {\r\n        return s_requestedVerifier[_userId];\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}